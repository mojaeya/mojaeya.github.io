I"+<h4 id="-데이터-베이스를-수정하는-것은-상당한-리스크가-있는-일이다때문에-데이터를-수정할-때는-실제로-db에-적용하지-않고-취소하는-기능이-필요하다이렇게-데이터를-실제로-수정하지-않고-취소-처리하는-것을-rollback이라고-하며rollback하기-위해서는-transaction을-통해-쿼리-명령어를-실행해야-한다-"><center>" 데이터 베이스를 <font color="#0086E5">수정</font>하는 것은 상당한 <font color="red">리스크</font>가 있는 일이다.<br />때문에 데이터를 수정할 때는 실제로 DB에 적용하지 않고 취소하는 기능이 필요하다.<br />이렇게 데이터를 실제로 수정하지 않고 취소 처리하는 것을 "Rollback"이라고 하며,<br />"Rollback"하기 위해서는 "Transaction"을 통해 쿼리 명령어를 실행해야 한다. "</center></h4>
<p><br />
<br />
이번 포스팅에선 SQL 절들을 수행 할 때, 모두 수행 되지 않을 경우, 원래의 상태로 돌리는 트랙잭션 처리에 대해서 알아보자.</p>

<h2 id="transaction-트랜잭션">Transaction (트랜잭션)</h2>

<ul>
  <li>연속된 작업을 뜻하는데, DB에서 이러한 트랙잭션은 DB 상태를 변화시키는 “<strong>쪼개질 수 없는 작업 단위</strong>“를 뜻한다.</li>
</ul>

<p>▶ <strong>ATM으로 계좌이체를 한다고 생각해보면,</strong></p>

<p>1. A 은행에서 출금하여 B은행으로 송금하려고 한다.</p>

<p>2. 송금 중, 알 수 없는 오류가 발생하여 A은행 계좌에서 돈은 빠져 나갔지만 B은행의 계좌에 입금되지 않았다.</p>

<p>3. 이와 같은 상황을 막기위해 거래가 성공적으로 모두 끝나야 이를 완전한 거래로 승인하고, 거래 도중 뭔가 오류가 발생했을 때는 이 거래를 처음부터 없었던 거래로 완전히 되돌린다.</p>

<p>이렇게 거래의 안정성을 확복하는 방법이 <strong><code class="language-plaintext highlighter-rouge">트랜잭션 처리</code></strong>이다.</p>

<h2 id="트랙잭션-처리">트랙잭션 처리</h2>

<ul>
  <li>트랜잭션을 모두 <strong><font color="#0086E5">성공</font></strong>/<strong><font color="red">실패</font></strong>를 하기 위한 처리이다.</li>
  <li><strong><font color="#0086E5">성공</font></strong>에 대해서는 신경쓸께 없지만, <strong><font color="red">실패</font></strong>일 경우, 작업중에 건들였던 테이블들을 모두 작업전으로 돌리는 작업이 필요하다.<br />
<strong>즉, 되돌리는 작업을 트랜잭션 처리라고 한다</strong>.<br />
<u>DB에선 처리 과정이 모두 성공했을 때만 최종적으로 DB에 반영합니다.<u></u></u></li>
</ul>

<p><br />
내 계좌의 잔액에서 이체한 금액만큼 빼는 일과, 상대 계좌의 잔액에서 해당 금액만큼 더하는 일은 쪼개어져서는 안된다.  <br />
두가지 명령 중 하나만 실행되서는 안되며 하나의 작업으로 함께 진행되어야 하는 일이기 때문이다.</p>

<h4 id="즉-더이상-쪼갤-수-없기-때문에-일부만-동작해선-안된다는-것이-트랜잭션의-핵심이다">즉, 더이상 쪼갤 수 없기 때문에 일부만 동작해선 안된다는 것이 트랜잭션의 핵심이다.</h4>

<p><br />
<br />
부분 작업들 여러개가 모여진 이러한 트랜잭션을 처리하기 위해 DB는 다음의 두가지 명령어를 활용하는데,</p>

<p>바로 <strong>Rollback(롤백)</strong>과 <strong>Commit(커밋)</strong>이다.  <strong>rollback</strong>과 <strong>commit</strong>은 Transaction 안에서 동작을 한다.</p>

<ul>
  <li><strong>Rollback(롤백) :</strong> 부분 작업이 실패하면 작업을 무효화하고 트랜잭션 실행 전으로 되돌린다.</li>
  <li><strong>Commit(커밋) :</strong> 모든 부분작업이 정상적으로 완료하면 이 변경사항을 한꺼번에 DB에 반영한다.</li>
</ul>

<table>
  <tbody>
    <tr>
      <td>[##_Image</td>
      <td>kage@msCSG/btrbABJBpQq/n2KE8MS6eoT2qLtc680j11/img.png</td>
      <td>CDM</td>
      <td>1.3</td>
      <td>{“originWidth”:1566,”originHeight”:362,”style”:”alignLeft”,”filename”:”스크린샷 2021-08-09 오후 7.19.21.png”}_##]</td>
    </tr>
  </tbody>
</table>

<p><strong>**▶ 명령어들을</strong> <strong>트랜잭션으로</strong> <strong>묶으려면</strong> <strong>SQL</strong> <strong>서버에선</strong> <strong>:  BEGIN TRANSACTION ~ COMMIT TRANSACTION</strong>** </p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Rollback 예제

router.post('/', function (req, res, next) {
  const body = req.body
  // pool.getConnection으로 connection을 가져옴
  pool.getConnection(function(err, connection) {
      if (err) throw err; // not connected!
      // beginTransaction으로 트랜잭션 처리 시작
      connection.beginTransaction(function(err) {
          if (err) { 
              res.status(200).json({error:err})                
          }            
          connection.query(
              'INSERT INTO products SET ?', 
              body,
              function (error, result, fields) {
                  if (error) {
                      connection.release() // 에러시 connection을 pool에 반납
                      return connection.rollback(function() { // rollback =&gt; 무효화                                   
                          res.status(200).json({error:error})                            
                      })
                  } 
                  connection.commit(function(err) { // commit =&gt; 쿼리를 실행시켜라
                      connection.release() // committed; 트랜잭션 종료했으니 반납
                      if (err) {
                          return connection.rollback(function() { // rollback =&gt; 무효화
                            res.status(200).json({err:err})                                
                          })
                      }
                      res.status(200).json({result})
                  })                       
          })          
      })
  })
})
</code></pre></div></div>

<p><strong>★ 트랜잭션 처리는 INSERT, UPDATE, DELETE 문만 가능하며, 다른것들은 트랙잭션 처리 되지 않는다.</strong></p>

<blockquote>
  <p><strong>왜 GET문은 안돼?</strong><br />
Get문은 정보를 가져오기만 하지, DB 상태를 변화시킬 일이 없기 때문에 트랙잰션 처리가 필요가 없고,<br />
수시로 데이터를 받아와야 하므로 DB와의 연결을 유지하고 있어야 하기 때문이다.</p>
</blockquote>

<p><strong>Reference</strong></p>

<p>* 본 포스팅은 아래 사이트를 참조 및 인용하여 개인공부 용도로 작성되었습니다.</p>

<p>  잘못된 내용 피드백 주시면 반영하겠습니다. 감사합니다.</p>

<p><a href="https://www.ikpil.com/1110">https://www.ikpil.com/1110</a></p>

<p><a href="https://devuna.tistory.com/30">https://devuna.tistory.com/30</a></p>

<p><br />
<br />
<br /></p>

<blockquote>
  <p><strong>Reference</strong> <br />
본 포스팅은 아래 사이트를 참조 및 인용하여 개인공부 용도로 작성되었습니다. <br />
잘못된 내용 피드백 주시면 반영하겠습니다. 감사합니다. <br />
<a href=""></a></p>
</blockquote>
:ET
I"<<p><strong>배열은 Array 타입 객체이며 Array.prototype의 프로퍼티를 상속 받는다. <br />
Array.prototype에는 수많은 메서드가 정의되어 있으며, 모든 배열은 이 메서드를 사용할 수 있다.</strong></p>

<p>Array</p>

<p>// 1. 선언</p>

<p>const arr1 = new Array()</p>

<p>const arr2 = [1,2]</p>

<p>// 인덱스 0부터 시작</p>

<h2 id="수정-메서드--원본-배열을-바로-수정-"><strong>수정 메서드</strong> ( <em>원본 배열을 바로 수정</em> )</h2>

<p>*<strong>*▶</strong> push 메서드** : 배열 마지막에 하나 이상의 요소를 추가한 다음 그 배열의 길이를 반환</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const fruits = ['🥝', '🍌']

fruits.push('🍎','🍉')  // 반환값 : 4
console.log(fruits)     // fruits : ['🥝', '🍌','🍎','🍉']
</code></pre></div></div>

<p>*<strong>*▶</strong> pop** <strong>메서드</strong> : 배열의 마지막 요소를 잘라내어 반환</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fruits.pop()        // 반환값 : '🍉'
console.log(fruits) // fruits : ['🥝', '🍌','🍎']
</code></pre></div></div>

<p>*<strong>*▶</strong> unshift 메서드** : 배열 앞부분에 요소를 추가 후 모든 배열 요소를 오른쪽으로 이동한 다음 그 배열의 길이를 반환</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fruits.unshift('🍋')  // 반환값 : 4
console.log(fruits)   // fruits : ['🍋','🥝', '🍌','🍎']
</code></pre></div></div>

<p>*<strong>*▶</strong> shift** <strong>메서드</strong> : 배열 첫번째 요소 제거 후 모든 배열 요소 왼쪽으로 이동</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fruits.shift()       // 반환값 : '🍋'
console.log(fruits)  // fruits : ['🥝', '🍌','🍎']
</code></pre></div></div>

<blockquote>
  <p><strong>note!! unshift, shift are slower than push, pop : 배열을 움직여야 되기 때문!</strong></p>
</blockquote>

<p>*<strong>*▶</strong> splice 메서드** : 특정 인덱스의 배열 요소를 갈아 끼울 때 사용하는 메서드(요소를 끼워넣기만, 삭제만 하는것도 가능)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const fruits = ['🥝', '🍌','🍎','🍉']
// 첫번째 인수 : 배열을 수정하기 시작할 위치
// 첫번째 인수만 넘기면 그 인덱스 이후에 있는 모든 배열 요소를 삭제
fruits.splice(1)     // 반환값 : '🍌','🍎','🍉'
console.log(fruits)  // fruits : ['🥝']

const fruits2 = ['🥝', '🍌','🍎','🍉']
// 두번째 인수 : 배열에서 삭제할 요소의 개수
fruits2.splice(1, 1)   // 반환값 : '🍌'
console.log(fruits2)   // fruits2 : ['🥝','🍎','🍉']

const fruits3 = ['🥝', '🍌','🍎','🍉']
// 세번째 인수 : 배열에 삽입할 요소의 값을 쉼표로 구분해서 넘김
fruits3.splice(1, 1, '🍒','🍊')   // 반환값 : '🍌'
console.log(fruits3)              // fruits3 : ['🥝','🍎','🍉','🍒','🍊']
</code></pre></div></div>

<p>*<strong>*▶</strong> sort 메서드** : 배열 안의 요소를 정렬 (인수로는 실제로 담담하는 함수의 참조를 넘기며 반환값은 정렬된 배열이다)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const a = [5,2,7,1,3,9,8]

a.sort(funtion(a,b) {return a-b})  // 반환값 : [1,2,3,5,7,8,9]
console.log(a)                     // a : [1,2,3,5,7,8,9]
</code></pre></div></div>

<p>비교함수는 배열안의 인접한 요소를 비교하는 역할을 한다. 비교함수는 인수를 두개 받고, 첫번째 인수는 인전합 왼쪽 요소,</p>

<p>두번째 인수는 인접한 오른쪽 요소이다. 비교함수를 f(a, b)라고 했을 때 비교함수는 다음 규칙을 따른다.</p>

<ul>
  <li>f(a, b) &lt; 0 이면 a를 b보다 작은 인덱스로 정렬한다.</li>
  <li>f(a, b) == 0 이면 a와 b의 순서를 바꾸지 않는다.</li>
  <li>f(a, b) &gt; 0 이면 b를 a보다 작은 인덱스로 정렬한다.</li>
</ul>

<p>*<strong>*▶</strong> reverse 메서드**</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const array = [1, 2, 3, 4, 5];

array.reverse()  // [5, 4, 3, 2, 1]
</code></pre></div></div>

<hr />

<h2 id="접근자-메서드--배열을-다른-모습으로-가공한-새로운-배열-반환-원래-배열-수정-x-"><strong>접근자 메서드</strong> ( 배열을 다른 모습으로 가공한 새로운 배열 반환,  원래 배열 수정 X )</h2>

<p>*<strong>*▶</strong> join 메서드** : 배열의 모든 요소 값을 문자열로 바꾼 후에 인수로 받은 문자로 연결해서 반환.</p>

<p>요소값이 undefined나 null일 때는 그 요소값을 빈문자로 간주.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const fruits = ['apple', 'banana', 'orange']

fruits.join("-")     // 'apple-banana-orange'

// 빈 문자를 지정하면 배열 요소의 모든값을 그대로 연결.
fruits.join("")    // 'applebananaorange'

// 인수를 지정하지 않으면 쉼표로 배열의 요소 값을 연결해 반환.
fruits.join()     // 'apple,banana,orange'
</code></pre></div></div>

<p>*<strong>*▶</strong> concat 메서드** : 인수로 받은 값을 그 배열의 요소로 추가해서 새로운 배열을 생성. 받은 인수가 배열이면 펼친후에 배열에 추가</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const a = ['A', 'B', 'C']

a.concat(['D','E'])   // ['A', 'B', 'C', 'D', 'E']

// 배열은 한번만 펼처서 추가한다.(배열을 재귀적으로 펼치지 않는다)
a.concat('D', ['E',['F','G']])   // ['A', 'B', 'C', 'D', 'E', ['F','G']]
</code></pre></div></div>

<p>concat 메서드는 인수값이 객체의 참조면 그 참조값을 복사한다.</p>

<p>따라서 원본 객체를 수정하면 concat 메서드가 반환한 배열의 요소도 함께 바뀐다.</p>

<p>*<strong>*▶</strong> slice 메서드** : 배열의 일부 요소를 제거한 새로운 배열을 반환</p>

<p>첫번째 인수(<strong>begin</strong>) : 요소를 꺼낼 시작위치를 뜻하는 인덱스</p>

<p>두번째 인수(<strong>end</strong>) : 요소를 꺼낼 마지막 위치를 뜻한 인덱스 ( slice 메서드는 end가 가리키는 요소의 바로 이전 요소까지만 잘라낸다)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const array = [1, 2, 3, 4, 5]

array.slice(2,5)    // [3, 4, 5]

// 두번째 인수인 end를 생략하면 마지막 요소까지 잘라낸다.
array.slice(3)      // [4, 5]

array.slice()    // [1, 2, 3, 4, 5]
</code></pre></div></div>

<p>*<strong>*▶</strong> indexOf 와 lastIndexOf 메서드** : 배열 안에서 인수로 지정한 값을 검색해서 가장 먼저 찾은 요소의 인덱스를 반환.</p>

<p>(찾지 못한 경우 -1 반환)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let a = ['A', 'B', 'C', 'C', 'D']

// 인덱스 앞에서부터
a.indexOf('C')           // 2

// 인덱스 뒤에서부터
a.lastIndexOf('C')       // 3

// 두번째 인수 : 검색을 시작할 인덱스
a.indexOf('C', 3)        // 3

// includes 메소드 : 인수로 지정한값이 배열에 포함되어 있는지 확인, 있으면 true 없으면 false로 반환
a.includes('F')         // false
</code></pre></div></div>

<p>*<strong>*▶</strong> toString과 toLocaleString 메서드** : 배열의 요소를 문자열로 변환하여 쉼표로 연결한 문자열을 반환</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const date = new Date()

console.log(['A', 'B', 'C', date].toString())  // 'A, B, C, Wed Jan 03 2018...'

// toLocalString : 해당 지역에 맞는 언어로 번역한 문자열 반환
console.log(['A', 'B', 'C', date].toLocaleString())  // 'A, B, C, 2018. 1. 3. 오후 ...'
</code></pre></div></div>

<p>*<strong>*▶</strong> filter 메서드** : 주어진 함수의 테스트를 통과하는 모든 요소를 모아 새로운 배열로 반환합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present']

const result = words.filter(word =&gt; word.length &gt; 6)

console.log(result) // ["exuberant", "destruction", "present"]
</code></pre></div></div>

<p>*<strong>*▶</strong> find 메서드** : 주어진 판별 함수를 만족하는 첫번째 요소의 값을 반환합니다. 그런 요소가 없다면 undefined를 반환합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const array1 = [5, 12, 8, 130, 44]

const found = array1.find(element =&gt; element &gt; 10)

console.log(found) // 12
</code></pre></div></div>

<p>*<strong>*▶</strong> some 메서드** : 배열 안의 어떤 요소라도 주어진 판별 함수를 통과하는지 테스트합니다**. (하나라도 통과하면 true)**</p>

<p>*<strong>*▶</strong> every 메서드** : 배열 안의 **모든** 요소가 주어진 판별 함수를 통과하는지 테스트합니다. Boolean 값을 반환합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// some 메서드
const array = [1, 2, 3, 4, 5];

const even = (element) =&gt; element % 2 === 0

console.log(array.some(even)) // true

// every 메서드
const array2 = [1, 30, 39, 29, 10, 13]

const even = (element) =&gt; element &lt; 40

console.log(array2.every(even))  // true
</code></pre></div></div>

<hr />

<h2 id="반복-메서드--배열의-모든-요소를-순회하며-특정한-작업을-수행하는-메소드"><strong>반복 메서드</strong> : 배열의 모든 요소를 순회하며 특정한 작업을 수행하는 메소드</h2>

<p><strong>forEach(반복 메서드), for..in(키값 출력 반복문) 처럼 기존 for문 반복문을 좀 더 편하게 쓰려고 시도를 했지만 효율적이지 않았다.</strong></p>

<p><strong>그래서 ES6부터 추가된 효율적인 반복문 for..of를 쓰는것을 권장한다.</strong></p>

<blockquote>
  <p>let years = [2001, 2010,2015, 2018];</p>
</blockquote>

<p>위와 같은 배열이 있을 때</p>

<p>*<strong>*▶</strong> forEach 메서드**</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>years.forEach((year) =&gt; {
    console.log(year);
    // 2001, 2010, 2015, 2018
})
</code></pre></div></div>

<p>* forEach는 배열의 내용을 출력할 수 있지만 가독성이 떨어지고 내부에서 break문 등을 사용할 수 없다. (사용권장 X)</p>

<p>*<strong>*▶</strong> for..of 반복문**</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for(let year of years){
  console.log(year);

  if(year == 2001){
       break;
  }
  // 2001
}
</code></pre></div></div>

<p>* for..of의 경우 배열의 내용을 출력할 수 있고 내부에서 break문도 사용 가능하다. (사용 권장)</p>

<p>*<strong>*▶</strong> map 메서드** : 인수로 받은 함수를 배열의 요소별로 한번씩 실행하며, 마지막에는 그 함수가 반환값으로 새로운 배열을 생성</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Student {
  constructor(name, age, enrolled, score) {
    this.name = name;
    this.age = age;
    this.enrolled = enrolled;
    this.score = score;
  }
}
const students = [
  new Student('A', 29, true, 45),
  new Student('B', 28, false, 80),
  new Student('C', 30, true, 90),
  new Student('D', 40, false, 66),
  new Student('E', 18, true, 88),
];
</code></pre></div></div>

<p>위에 같은 클래스와 배열이 있을때,</p>

<p><strong>Quiz) student의 score만을 포함하는 배열을 만들어라 (map 메서드 활용)</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const result = students.map(student =&gt; student.score)

console.log(result)  // [45, 80, 90, 66, 88]
</code></pre></div></div>

<p><strong>▶ reduce 메서드</strong> : 배열의 첫번째 요소부터 마지막 요소까지의 합성곱 처리를 한다.</p>

<blockquote>
  <p><strong>합섭 곱 처리란?</strong><br />
**배열 요소 하나를 함수로 처리한 후에 그 반환값을 다음 번 요소를 처리할 때 함수의 입력 값으로 사용하는 처리 방법<br />
**</p>
</blockquote>

<ul>
  <li><strong>initial(초기값) 지정함</strong> : prev는 initial의 값, curr은 배열의 첫번째 요소, index는 0</li>
  <li><strong>initial(초기값) 지정안함</strong> : prev는 배열의 첫번째 요소 값, curr은 배열의 두번째 요소 값, index는 1</li>
</ul>

<p>위에서 본 클래스와 배열문을 이용해 또 문제를 하나 풀자면,</p>

<p><strong>Quiz) student의 평균 점수를 계산해라. (reduce 메서드 활용)</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const result = students.reduce((prev, curr) =&gt; {
    //console.log(prev)     -&gt; reduce 메소드 이해가 잘 안가면 이렇게 로그를 직접 찍어가면서 이해해보자
    //console.log(curr)
    return  prev + curr.score
  },0)  // initial 초기값을 0으로 지정

  console.log(result / students.length)  // 369 / 5 = 73.8
</code></pre></div></div>

<p>String.prototype.split()</p>

<p>split()함수 : 문자열을 일정한 구분자로 잘라서 배열로 저장</p>

<p>split() : 구분자가 없기 때문에 문자열 그대로 리턴</p>

<p>split(‘’) : 공란문자 즉 글자 하나하나로 구분된다.</p>

<p>split(‘ ‘) : space 문자를 기준으로 구분된다.</p>

<p><br />
<br />
<br /></p>

<blockquote>
  <p><strong>Reference</strong><br />
본 포스팅은 아래 사이트를 참조 및 인용하여 개인공부 용도로 작성되었습니다.<br />
잘못된 내용 피드백 주시면 반영하겠습니다. 감사합니다.
<a href="https://velog.io/@takeknowledge/javscript-ES6%EC%97%90-%EC%B6%94%EA%B0%80%EB%90%9C-%EA%B8%B0%EB%8A%A5-%EA%B0%84%EB%8B%A8-%EC%A0%95%EB%A6%AC">https://velog.io/@takeknowledge/javscript-ES6에-추가된-기능-간단-정리</a><br />
<a href="https://www.youtube.com/watch?v=yOdAVDuHUKQ&amp;list=PLv2d7VI9OotTVOL4QmPfvJWPJvkmv6h-2&amp;index=8">https://www.youtube.com/watch?v=yOdAVDuHUKQ&amp;list=PLv2d7VI9OotTVOL4QmPfvJWPJvkmv6h-2&amp;index=8</a><br />
<a href="https://www.youtube.com/watch?v=3CUjtKJ7PJg&amp;list=PLv2d7VI9OotTVOL4QmPfvJWPJvkmv6h-2&amp;index=9">https://www.youtube.com/watch?v=3CUjtKJ7PJg&amp;list=PLv2d7VI9OotTVOL4QmPfvJWPJvkmv6h-2&amp;index=9</a><br />
<a href="https://developer.mozilla.org/ko/">https://developer.mozilla.org/ko/</a></p>
</blockquote>
:ET
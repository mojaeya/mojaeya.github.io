I"5<p><br />
데이터 값을 가져오는 방식으로는  <strong><code class="language-plaintext highlighter-rouge">body</code></strong> 랑 <strong><code class="language-plaintext highlighter-rouge">query</code></strong>가 있다. </p>

<p>body data : <strong>req.body</strong></p>

<p> <strong>=&gt;</strong> Client에서 보내주는 JSON, XML, Multi Form 등의 데이터를 담는다. 주소에서는 확인할 수 없다.</p>

<p>주소 (query string) <strong>: </strong>req.query<em>**</em></p>

<p><strong>**=&gt;</strong>** 주소 바깥 ? 이후의  변수를 담는다. ? 뒤에 오는 것들이 바로 query string</p>

<p><strong>req.query</strong>는 순수 node.js에는 없는 명령어다. <strong>Express</strong> 환경에서 주어지는 명령어다.</p>

<p><strong>req.query</strong> 문을 통해 데이터를 가져오면 client가 url을 통해 요청한 데이터를 내보낼 수 있다. </p>

<p>호출 : localhost:3000?idx=1&amp;name=asdf   =&gt;  req.query가  { idx: ‘1’, name: ‘asdf’ } 처럼 객체 형태로 값을 받아온다.</p>

<hr />

<h2 id="injection-attak"> <strong>Injection Attak</strong></h2>

<p>그럼 본격적으로  <strong>Injection Attak</strong> 에 대해 알아보자.</p>

<p>아래와 같이 <strong>쿼리폼</strong>을 활용해 sql이라는 쿼리문을 만들었다. </p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let sql = 'SELECT * FROM products WHERE idx = "'+idx+'"'
</code></pre></div></div>

<p>우리가 예상하는 모습은 다음과 같다.</p>

<p>호출 : <strong>localhost:3000?idx=1</strong></p>

<p>적용 된 sql : <strong>SELECT * FROM products WHERE idx = “1”</strong></p>

<p>=&gt; idx = 1 에 해당하는 데이터를 가져오게 됨</p>

<p>하지만 이러한 <strong>쿼리폼</strong>은 <strong>Injection Attak(인젝션 공격)</strong> 에 <strong>취약한</strong> 형태이다.</p>

<p><strong>▶</strong> <strong>인젝션 공격</strong> </p>

<p>호출(공격) : <strong>localhost:3000?idx=whatever” or 1=”1</strong> </p>

<p>적용 된 sql : <strong>SELECT * FROM products WHERE idx = “whatever” or 1=”1”</strong></p>

<p><strong>=&gt; 모든 데이터를 가져오게 됨</strong> </p>

<h2 id="injection-attak을-막는-방법"><strong>Injection Attak을 막는 방법</strong></h2>

<p><strong>인젝션 공격을 막는 방법은 1. escape 함수(변수를 string으로 encoding 해주는 함수),</strong></p>

<p><strong>2. Bind 변수(=?) 활용, 3. 쿼리안에 timeout 을 거는 방법 등이 있다.</strong></p>

<h3 id="바인딩-쿼리"><strong>바인딩 쿼리</strong> </h3>

<p><strong>그 중 가장 간편하고 권장되는 방식 Bind 변수(=?)를 활용해 아래와 같이 쿼리문을 작성해보자.</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 권장되는 방식
 // const product = req.body
 
 // INSERT
 pool.query('INSERT INTO products SET ?',
 	product, 
    function (error, results, fields) {
    if (error) throw error;
    // Neat!
 });


// SELECT
 let columns = ['name'] // 1개일때는 array 아니어도 됨
 pool.query('SELECT ?? FROM ?? WHERE idx = ?', 
   [columns, 'products', idx], 
   function (error, results, fields) {
   if (error) {
     console.log('error : ', error)
   };
   // ...
   res.json({results})
 });
</code></pre></div></div>

<p><strong>변수가 삽입될 부분을 ‘Bind 변수’라고 불리는 “?”로 대체하여 쿼리문을 작성한다.</strong></p>

<p>그리고 <strong>INSERT문</strong>을 보면 SET 다음 ? 에 Client가 입력한 정보인 product가 할당되는 것이다.</p>

<p>참고로 Client가 입력한 정보인 product가 테이블 products의 column들에 포함되어 있다면 일일이 적어줄 필요가 없다.</p>

<p>DB에 이미 테이블 products의 column들이 할당되어 있기 때문에</p>

<p>Client가 입력한 정보인 product가 column에 맞게 알아서 찾아  들어가준다.</p>

<p><em>어차피 프론트에선 정해진 규칙대로 정보를 보내야 하기 때문이다.</em></p>

<p>이때 Bind 변수는 자체적으로 들어오는 데이터를 필터링하고 위험한 요소를 제거해준다.</p>

<p>따라서 정상적이지 않은 방식으로 접근했을 때 결과값을 출력하지 않는다.</p>

<p><strong>SELECT문</strong>을 통해 알아야 할 것</p>

<ul>
  <li>Bind 변수에서는 물음표 2개(??)는 table, columns 등이 필요할 때 사용되고 물음표 1개(?)는 실제 값을 넣을 때 사용한다.</li>
  <li>배열변수에 ? 가 할당된 순서대로  변수를 할당한다.</li>
</ul>

<p><br />
<br />
<br /></p>

<blockquote>
  <p><strong>Reference</strong> <br />
본 포스팅은 아래 사이트를 참조 및 인용하여 개인공부 용도로 작성되었습니다. <br />
잘못된 내용 피드백 주시면 반영하겠습니다. 감사합니다. <br />
<a href="https://jungeunpyun.tistory.com/21?category=911250">https://jungeunpyun.tistory.com/21?category=911250</a></p>
</blockquote>
:ET